<!--
Google IO 2012/2013 HTML5 Slide Template

Authors: Eric Bidelman <ebidel@gmail.com>
         Luke Mahé <lukem@google.com>

URL: https://code.google.com/p/io-2012-slides
--><!DOCTYPE html>


<html>
<head>
  <title>Appendix 1 : Reproducible Research using Snakemake &mdash; Genome Analysis Workshop 0.2 documentation</title>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">-->
  <!--<meta name="viewport" content="width=device-width, initial-scale=1.0">-->
  <!--This one seems to work all the time, but really small on ipad-->
  <!--<meta name="viewport" content="initial-scale=0.4">-->
  <meta name="apple-mobile-web-app-capable" content="yes">

  <meta name="hieroglyph-title" data-config-title>
  <meta name="hieroglyph-subtitle" data-config-subtitle>
  <meta name="hieroglyph-presenter" data-config-presenter>

  
  <link rel="stylesheet" media="all"
        href="../_static/theme/css/default.css">
  <link rel="stylesheet" media="all"
        href="../_static/theme/css/hieroglyph.css">
  <link rel="stylesheet" media="only screen and (max-device-width: 480px)"
        href="../_static/theme/css/phone.css">

    

    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <base target="_blank"> <!-- This amazingness opens all links in a new tab. -->
  
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>

    <script data-main="../_static/js/slides"
            src="../_static/js/require-1.0.8.min.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="Genome Analysis Workshop 0.2 documentation" href="../index.html" />
    <link rel="up" title="Class list" href="../Classes.html" />
    <link rel="next" title="Exercises" href="../Exercises.html" />
    <link rel="prev" title="Class 24 : Exome-Seq - Variants" href="class-24.html" /> 

<!-- Google Analytics tracking code -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54095998-2', 'auto');
  ga('send', 'pageview');

</script>


</head>
<body style="opacity: 0">

<slides class="layout-widescreen">

  

  
    <slide class="title-slide segue nobackground level-1" id="appendix-1-reproducible-research-using-snakemake">
    <hgroup>
      <h1>Appendix 1 : Reproducible Research using Snakemake<a class="headerlink" href="../../Classes/snakemake-tutorial.html#appendix-1-reproducible-research-using-snakemake" title="View HTML">§</a></h1>
    </hgroup>
    <article class="">
      <table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Last updated:</th><td class="field-body">Jan 26, 2017</td>
</tr>
</tbody>
</table>




    </article>
  </slide>  <slide class="level-2" id="goals">
    <hgroup>
      <h2>Goals<a class="headerlink" href="../../Classes/snakemake-tutorial.html#goals" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <ol class="arabic simple">
<li>Introduce reproducible research methods using pipelines and
<a class="reference external" href="https://snakemake.readthedocs.io/en/latest/index.html">Snakemake</a></li>
<li>Generate Snakemake pipeline for Chip-Seq analysis</li>
</ol>




    </article>
  </slide>  <slide class="level-2" id="overview">
    <hgroup>
      <h2>Overview<a class="headerlink" href="../../Classes/snakemake-tutorial.html#overview" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <p>Genomics analysis projects often generate hundreds or thousands of files.
Keeping track of all of the scripts used to generate a set of finalized
reports is an error-prone and difficult task.</p>
<p>The naive approach to organizing a project is to make a <code class="docutils literal"><span class="pre">bash</span></code> script
that executes each step of the analysis from mapping to plotting.</p>
<p>Organizing a project in this manner is a good first step to producing
reproducible analyses, however there are few common problems with this
approach.</p>
<p>For example:</p>
<ol class="arabic simple">
<li>After plotting all of your results you realize that you need to rerun
the peak calling step, but in order to do that you need to rerun the
entire pipeline.</li>
<li>The script might grow to be 1,000s of lines of code making debugging
very tedious as mistakes will be hard to spot.</li>
</ol>
<p>The next approach might be to split each important set of steps into
individual scripts. i.e:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">run_mapping.sh</span></code></li>
<li><code class="docutils literal"><span class="pre">call_peaks.sh</span></code></li>
<li><code class="docutils literal"><span class="pre">plot_data.R</span></code></li>
</ol>
<p>By modularizing the code, the workflow is easier to modify and it
becomes easier to reuse the code. However, with this setup a few
additional problems can occur.</p>
<ol class="arabic simple">
<li>You rerun the <code class="docutils literal"><span class="pre">run_mapping.sh</span></code> script, but forget to rerun
<code class="docutils literal"><span class="pre">call_peaks.sh</span></code> and <code class="docutils literal"><span class="pre">plot_data.R</span></code>. Two weeks later you discover your
mistake...</li>
<li>You edit and rerun <code class="docutils literal"><span class="pre">call_peaks.sh</span></code> but an error occurs, and now you are unsure
which of the hundreds of files you generated are new or old.</li>
</ol>
<p>For these reasons, it is a very good practice to use a workflow management
system to help with managing computational projects.</p>




    </article>
  </slide>  <slide class="level-2" id="installation">
    <hgroup>
      <h2>Installation<a class="headerlink" href="../../Classes/snakemake-tutorial.html#installation" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <div class="highlight-bash"><div class="highlight"><pre><span></span>easy_install3 snakemake
<span class="c1">#or</span>
pip3 install snakemake
<span class="c1">#or</span>
conda install -c bioconda snakemake
</pre></div>
</div>




    </article>
  </slide>  <slide class="level-2" id="id1">
    <hgroup>
      <h2>Snakemake<a class="headerlink" href="../../Classes/snakemake-tutorial.html#id1" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <p><a class="reference external" href="https://snakemake.readthedocs.io/en/latest/index.html">Snakemake</a> is a
worflow manangement system that is based upon GNU Make and uses python
syntax.</p>
<p>The central idea of a snakemake workflow is that we define a set of rules
that specify how to generate output files from input files.</p>
<p>For example:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># generate an example file</span>
$ <span class="nb">echo</span> <span class="s2">&quot;world&quot;</span> &gt; world.txt
</pre></div>
</div>
<p>We define a set of rules to use to generate output files from input files.
Copy the following code into a file named <code class="docutils literal"><span class="pre">Snakefile</span></code> (no extension).</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nf">rule hello_world</span><span class="o">:</span>
  input:
    <span class="s2">&quot;world.txt&quot;</span>
  output:
    <span class="s2">&quot;hello_world.txt&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    echo &quot;</span>Hello<span class="s2">&quot; \</span>
<span class="s2">      | cat - {input} &gt; {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Now let's use Snakemake to execute our rule.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>snakemake -npr hello_world.txt
<span class="c1"># -npr tells snakemake to do a dry run and print the expected commands</span>
</pre></div>
</div>
<p>As we can see snakemake has filled in the <code class="docutils literal"><span class="pre">{input}</span></code> and <code class="docutils literal"><span class="pre">{output}</span></code> variables
for our rule. Next go ahead and exectute this simple rule (remove
<code class="docutils literal"><span class="pre">-npr</span></code>).</p>
<p>Now here's where snakemake get's useful. Go ahead and change the contents
of the <code class="docutils literal"><span class="pre">world.txt</span></code> file. Now when we reexecute Snakemake, it knows that
<code class="docutils literal"><span class="pre">world.txt</span></code> has been edited, and that <code class="docutils literal"><span class="pre">hello_world.txt</span></code> also needs to
be regenerated</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>snakemake -npr hello_world.txt
</pre></div>
</div>
<p>Snakemake will automatically reexecute a rule if the input files have been
modified. If we have many rules, then any intermediate files will also be
regenerated. For example, add another rule that now edits
<code class="docutils literal"><span class="pre">hello_world.txt</span></code>:</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nf">rule hello_universe</span><span class="o">:</span>
  input:
    <span class="s2">&quot;hello_world.txt&quot;</span>
  output:
    <span class="s2">&quot;hello_universe.txt&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    sed &#39;s/world/universe/&#39; {input} &gt; {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre><span></span>snakemake -npr hello_world.txt
</pre></div>
</div>
<p>Instead of defining our target files on the command line we can specify
them directly in the <code class="docutils literal"><span class="pre">Snakefile</span></code>. Rule <code class="docutils literal"><span class="pre">all</span></code> is a psuedo-rule that
simply tells snakemake what final files to generate. By default snakemake
determines which rule to execute first in a top-down manner. It will
therefore first search for <code class="docutils literal"><span class="pre">hello_universe.txt</span></code>, then will find the rule
that generates it (<code class="docutils literal"><span class="pre">rule</span> <span class="pre">hello_universe</span></code>), then execute any additional rule
dependencies, until all target files have been generated.</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nf">rule all</span><span class="o">:</span>
  input:
    <span class="s2">&quot;hello_universe.txt&quot;</span>

<span class="nf">rule hello_universe</span><span class="o">:</span>
  input:
    <span class="s2">&quot;hello_world.txt&quot;</span>
  output:
    <span class="s2">&quot;hello_universe.txt&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    sed &#39;s/world/universe/&#39; {input} &gt; {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="nf">rule hello_world</span><span class="o">:</span>
  input:
    <span class="s2">&quot;world.txt&quot;</span>
  output:
    <span class="s2">&quot;hello_world.txt&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    echo &quot;</span>Hello<span class="s2">&quot; \</span>
<span class="s2">      | cat - {input} &gt; {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>
</pre></div>
</div>




    </article>
  </slide>  <slide class="level-2" id="generalizing-rules-with-wildcards">
    <hgroup>
      <h2>Generalizing rules with wildcards<a class="headerlink" href="../../Classes/snakemake-tutorial.html#generalizing-rules-with-wildcards" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <p>Snakemake supports using wildcards to define the <code class="docutils literal"><span class="pre">input</span></code> and <code class="docutils literal"><span class="pre">output</span></code>
files. This is extremely powerful as we can now generalize our rules to
many different inputs/outputs.</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nv">PLACES</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;hello_universe.txt&quot;</span>,
          <span class="s2">&quot;hello_colorado.txt&quot;</span>,
          <span class="s2">&quot;hello_123.txt&quot;</span><span class="o">]</span>

<span class="nf">rule all</span><span class="o">:</span>
    input:
      PLACES <span class="c1">#list of files is substituted</span>

<span class="nf">rule hello_universe</span><span class="o">:</span>
    input:
      <span class="s2">&quot;hello_world.txt&quot;</span>
    output:
      <span class="s2">&quot;hello_{place}.txt&quot;</span>
      <span class="c1">#the place variable is autofilled based on matching the output</span>
    shell:
      <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">      sed &#39;s/world/{wildcards.place}/&#39; {input} &gt; {output}</span>
<span class="s2">      #to access a wildcard in a shell command use {wildcards.place}</span>
<span class="s2">      &quot;&quot;&quot;</span>

<span class="nf">rule hello_world</span><span class="o">:</span>
  input:
    <span class="s2">&quot;world.txt&quot;</span>
  output:
    <span class="s2">&quot;hello_world.txt&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    echo &quot;</span>Hello<span class="s2">&quot; \</span>
<span class="s2">      | cat - {input} &gt; {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Snakemake has a helpful python function called <code class="docutils literal"><span class="pre">expand</span></code> that simplifies
the above code to:</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nv">PLACES</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;universe&quot;</span>,
          <span class="s2">&quot;colorado&quot;</span>,
          <span class="s2">&quot;123&quot;</span><span class="o">]</span>

<span class="nf">rule all</span><span class="o">:</span>
    input:
      expand<span class="o">(</span><span class="s2">&quot;hello_{place}.txt, place=PLACES) #list of files is substituted</span>
</pre></div>
</div>
<p>To check that your variable substitutions are correct you can use the
python <code class="docutils literal"><span class="pre">print()</span></code> function, which will print the substitued variables to
standard out, or alternatively look at the snakemake output (<code class="docutils literal"><span class="pre">-npr</span></code>)</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span>PLACES = [&quot;universe&quot;,
          &quot;colorado&quot;,
          &quot;123&quot;]

print(expand(&quot;hello_{place}.txt, place=PLACES))
</pre></div>
</div>




    </article>
  </slide>  <slide class="level-2" id="snakemake-pipeline-for-chip-seq-analysis">
    <hgroup>
      <h2>Snakemake pipeline for Chip-Seq analysis<a class="headerlink" href="../../Classes/snakemake-tutorial.html#snakemake-pipeline-for-chip-seq-analysis" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <p>So far our current pipeline isn't very useful. Next we'll write a short
pipeline to conduct basic Chip-Seq analysis. In this case we will use
H3k4me3 Chip-Seq data from hESC cells generated by the encode project,
with the goal of examining the distribution of H3k4me3 around human
Transcriptional Start Sites (TSS).</p>
<p>Important steps for the pipeline:</p>
<ol class="arabic simple">
<li>Map the data to the genome using <code class="docutils literal"><span class="pre">bowtie2</span></code> (FASTA -&gt; BAM)</li>
<li>Sort and Index <cite>BAM</cite> (BAM -&gt; Sorted BAM)</li>
<li>Get coverage using <code class="docutils literal"><span class="pre">bedtools</span> <span class="pre">genomecov</span></code> (BAM -&gt; bedGraph)</li>
<li>Plot coverage over TSS using bedtools/R` (bedGraph -&gt; pdf)</li>
</ol>
<p>Some of the steps in the pipeline were covered in the Bedtools vignette class.</p>
<p>First let's download some example data and make sure that we have all of
the necessary software installed.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>wget -m example_data
brew install bowtie2 samtools bedtools
</pre></div>
</div>
<p>Make a new file named <code class="docutils literal"><span class="pre">Snakefile</span></code> in the example_data directory.</p>
<p>Let's start our pipeline by defining a few important variables
for our analysis. Place these at the top of your Snakefile.</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nv">FASTA</span> <span class="o">=</span> <span class="s2">&quot;dbases/chr22.fa&quot;</span> <span class="c1"># our genome fasta file (hg19)</span>
<span class="nv">CHROMS</span> <span class="o">=</span> <span class="s2">&quot;dbases/chr22_length.txt&quot;</span> <span class="c1"># our genome file necessary for bedtools</span>
<span class="nv">GENES</span> <span class="o">=</span> <span class="s2">&quot;dbases/knownGene_chr22.bed&quot;</span> <span class="c1"># gene annotations for hg19</span>
</pre></div>
</div>
<p>It is convienent to organize the pipeline in a bottom-to-top fashion,
whereby the first steps executed are at the bottom.</p>
<p>For this analysis we will first align the Chip-Seq data using <code class="docutils literal"><span class="pre">bowtie2</span></code>.
First we'll generate the index necessary for alignment, then perform the
alignment.</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nf">rule bowtie_mapping</span><span class="o">:</span>
  input:
    <span class="nv">fq</span> <span class="o">=</span> <span class="s2">&quot;raw_data/{chip}.fastq.gz&quot;</span>,
    <span class="nv">idx</span> <span class="o">=</span> <span class="s2">&quot;dbases/bowtie_idx/chr22.1.bt2&quot;</span>
  output:
    <span class="s2">&quot;bowtie/{chip}.bam&quot;</span>
  params:
    <span class="nv">idx</span> <span class="o">=</span> <span class="s2">&quot;dbases/bowtie_idx/chr22&quot;</span>,
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    bowtie2 \</span>
<span class="s2">      -x {params.idx} \</span>
<span class="s2">      -U {input.fq} \</span>
<span class="s2">      -S {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="nf">rule bowtie_index</span><span class="o">:</span>
  <span class="c1"># add variable for output_dir</span>
  input:
    FASTA
  output:
    <span class="s2">&quot;dbases/bowtie_idx/chr22.1.bt2&quot;</span>
  params:
    <span class="nv">output_name</span> <span class="o">=</span> <span class="s2">&quot;dbases/bowtie_idx/chr22&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    bowtie2-build {input} {params.output_name}</span>
<span class="s2">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>These rules demonstrate a few important concepts:</p>
<ol class="arabic simple">
<li>multiple <code class="docutils literal"><span class="pre">inputs</span></code> or <code class="docutils literal"><span class="pre">outputs</span></code> can be defined and called by name
i.e. (<code class="docutils literal"><span class="pre">input.fq</span></code>). Each input must be separated by a comma.</li>
<li>Arbitrary additional arguments can be specified using the <code class="docutils literal"><span class="pre">params</span></code>
option. This is useful for customizing the command line arguments
with variables, but not requiring input or output dependencies.</li>
<li>We have a wildcard (<code class="docutils literal"><span class="pre">chip</span></code>) that takes the place of the fastq name.
This wildcard will allow us to generalize our pipeline.</li>
<li>Global variables, such as <code class="docutils literal"><span class="pre">FASTA</span></code> can be used as an input.</li>
<li>Snakemake will automatically generate directories that are listed in
the output files, if they do not exist.</li>
</ol>
<p>Check that our snakemake pipeline is working:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>snakemake -npr -s Snakefile bowtie/H1_h3k4me3_chr22.bam
</pre></div>
</div>
<p>Snakemake will pattern match our requested file
(<code class="docutils literal"><span class="pre">bowtie/H1_h3k4me3_chr22.bam</span></code>) and determine that it can make this file
by substituting <code class="docutils literal"><span class="pre">H1_h3k4me_chr22</span></code> for the <code class="docutils literal"><span class="pre">chip</span></code> variable.</p>
<p>Next we will sort and index the bam alignment file, then calculate
alignment coverage across the genome with bedtools.</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nf">rule make_bedgraphs</span><span class="o">:</span>
  input:
    <span class="s2">&quot;bowtie/{chip}_sorted.bam&quot;</span>
  output:
    <span class="s2">&quot;bowtie/{chip}.bedgraph&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    bedtools genomecov \</span>
<span class="s2">      -ibam {input} \</span>
<span class="s2">      -bg \</span>
<span class="s2">      -g {CHROMS} \</span>
<span class="s2">      &gt; {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="nf">rule sort_index_bam</span><span class="o">:</span>
  input:
    <span class="s2">&quot;bowtie/{chip}.bam&quot;</span>
  output:
    <span class="s2">&quot;bowtie/{chip}_sorted.bam&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    samtools sort {input} &gt; {output}</span>
<span class="s2">    samtools index {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Notice that we execute two commands in one rule (<code class="docutils literal"><span class="pre">sort_index_bam</span></code>).
Snakemake doesn't pay attention to what you execute, but instead tracks
the input and output files to ensure that they were generated correctly.
Combining multiple commands in one rule is useful for simple steps that
are commonly executated together.</p>
<p>Also note that we used the global variable <code class="docutils literal"><span class="pre">CHROMS</span></code> directly in the
shell command. The braces are needed in the shell command so that
snakemake can recognize it, but are not needed when calling the variable
outside of the shell commands.</p>
<p>Let's check that our pipeline is working by trying to generate the
bedgraph file.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>snakemake -npr -s Snakefile bowtie/H1_h3k4me3_chr22.bedgraph
</pre></div>
</div>
<p>Now that we have our bedgraph we next need to define a set of intervals to
surround the TSS to calculate H3k4me3 coverage. To do this we will use
<code class="docutils literal"><span class="pre">awk</span></code> and <code class="docutils literal"><span class="pre">bedtools</span></code>.</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nf">rule get_coverage</span><span class="o">:</span>
  input:
    <span class="nv">windows</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/windows.bed&quot;</span>,
    <span class="nv">bedgraph</span> <span class="o">=</span> <span class="s2">&quot;bowtie/{chip}.bedgraph&quot;</span>
  output:
    <span class="nv">coverage</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/{chip}/coverage.bed&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    #map and group data</span>
<span class="s2">    bedtools map -a {input.windows} \</span>
<span class="s2">      -b {input.bedgraph} \</span>
<span class="s2">      -c 4 -o mean -null 0 \</span>
<span class="s2">      | sort -k5,5n \</span>
<span class="s2">      | bedtools groupby \</span>
<span class="s2">        -i - \</span>
<span class="s2">        -g 5 -c 6 -o sum \</span>
<span class="s2">        &gt; {output.coverage}</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="nf">rule prepare_bed_data</span><span class="o">:</span>
  input:
    <span class="nv">genes</span> <span class="o">=</span> GENES,
    <span class="nv">chroms</span> <span class="o">=</span> CHROMS,
  output:
    <span class="nv">tss</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/tss.bed&quot;</span>,
    <span class="nv">tss_slop</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/tss_slop.bed&quot;</span>,
    <span class="nv">windows</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/windows.bed&quot;</span>,
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    #get start sites</span>
<span class="s2">    awk &#39; {{OFS=&quot;</span><span class="se">\t</span><span class="s2">&quot;}}</span>
<span class="s2">      </span><span class="nv">$6</span><span class="s2"> == &quot;</span>+<span class="s2">&quot; {{print </span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">+1,</span><span class="nv">$4</span><span class="s2">}} ;</span>
<span class="s2">      </span><span class="nv">$6</span><span class="s2"> == &quot;</span>-<span class="s2">&quot; {{print </span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$3</span><span class="s2">-1,</span><span class="nv">$3</span><span class="s2">,</span><span class="nv">$4</span><span class="s2">}}&#39; {input.genes} &gt; {output.tss}</span>

<span class="s2">    #get +/- 2kbp and make windows</span>
<span class="s2">    bedtools slop \</span>
<span class="s2">      -b 2000 \</span>
<span class="s2">      -i {output.tss} \</span>
<span class="s2">      -g {input.chroms} \</span>
<span class="s2">      &gt; {output.tss_slop}</span>

<span class="s2">    bedtools makewindows -b {output.tss_slop} -w 5 -i srcwinnum \</span>
<span class="s2">      | sort -k1,1 -k2,2n \</span>
<span class="s2">      | tr &quot;</span>_<span class="s2">&quot; &quot;</span><span class="se">\t</span><span class="s2">&quot; \</span>
<span class="s2">      &gt; {output.windows}</span>
<span class="s2">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>These rules take the reference gene annotations and extract out the TSS,
then make a set of windows surrounding the TSS, followed by calculating a
coverage summary over these windows.</p>
<p>Note:</p>
<ol class="arabic simple">
<li>When calling a shell command with braces (<code class="docutils literal"><span class="pre">{}</span></code>), they need to be
double bracketed. This is necessary otherwise snakemake would interpret
the braces as a snakemake variable</li>
</ol>
<p>These rules are very verbose, and it may actually be easier to have these
steps listed in a seperate shell script which you can call from snakemake.</p>
<p>Let's check that our pipeline is correct by trying to generate the
output from the <code class="docutils literal"><span class="pre">get_coverage</span></code> rule.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>snakemake -npr -s Snakefile <span class="s2">&quot;bedfiles/H1_h3k4me3_chr22/coverage.bed&quot;</span>
</pre></div>
</div>
<p>Lastly, let's plot the data using the <cite>bin/plot_data.R</cite> script.</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nf">rule plot_coverage</span><span class="o">:</span>
  input:
    <span class="nv">coverage</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/{chip}/coverage.bed&quot;</span>
  output:
    <span class="s2">&quot;plots/{chip}.pdf&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    ./bin/plot_data.R {input} {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>Note that we are calling an external script that performs the plotting.
Snakemake doesn't care what commands we run, only that the input files are
present before running and that the output files are generated after
executing the commands.</p>
<p>Again check the commands:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>snakemake -npr -s Snakefile <span class="s2">&quot;plots/H1_h3k4me3_chr22.pdf&quot;</span>
</pre></div>
</div>
<p>To clean up the pipeline let's define our target files in the Snakefile
itself.</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nv">CHIP</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;H1_h3k4me3_chr22&quot;</span><span class="o">]</span>

<span class="nf">rule all</span><span class="o">:</span>
  input: exand<span class="o">(</span><span class="s2">&quot;plots/{chip}.pdf&quot;</span>, <span class="nv">chip</span> <span class="o">=</span> CHIP<span class="o">)</span>
</pre></div>
</div>
<p>Now we can call our Snakefile directly. In fact we don't need to list the
Snakefile as snakemake will autodetect any file named <code class="docutils literal"><span class="pre">Snakefile</span></code> in the
current working directory</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>snakemake -npr
</pre></div>
</div>




    </article>
  </slide>  <slide class="level-2" id="putting-it-all-together">
    <hgroup>
      <h2>Putting it all together<a class="headerlink" href="../../Classes/snakemake-tutorial.html#putting-it-all-together" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nv">FASTA</span> <span class="o">=</span> <span class="s2">&quot;dbases/chr22.fa&quot;</span> <span class="c1"># our genome fasta file (hg19)</span>
<span class="nv">CHROMS</span> <span class="o">=</span> <span class="s2">&quot;dbases/chr22_length.txt&quot;</span> <span class="c1"># our genome file for bedtools</span>
<span class="nv">GENES</span> <span class="o">=</span> <span class="s2">&quot;dbases/knownGene_chr22.bed&quot;</span> <span class="c1"># gene annotations for hg19</span>

<span class="nv">CHIP</span> <span class="o">=</span> <span class="o">[</span><span class="s1">&#39;H1_h3k4me3_chr22&#39;</span><span class="o">]</span>

<span class="nf">rule all</span><span class="o">:</span>
  input: expand<span class="o">(</span><span class="s2">&quot;plots/{chip}.pdf&quot;</span>, <span class="nv">chip</span><span class="o">=</span>CHIP<span class="o">)</span>

<span class="nf">rule plot_coverage</span><span class="o">:</span>
  input:
    <span class="nv">coverage</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/{chip}/coverage.bed&quot;</span>
  output:
    <span class="s2">&quot;plots/{chip}.pdf&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    ./bin/plot_data.R {input} {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="nf">rule get_coverage</span><span class="o">:</span>
  input:
    <span class="nv">windows</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/windows.bed&quot;</span>,
    <span class="nv">bedgraph</span> <span class="o">=</span> <span class="s2">&quot;bowtie/{chip}.bedgraph&quot;</span>
  output:
    <span class="nv">coverage</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/{chip}/coverage.bed&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    #map and group data</span>
<span class="s2">    bedtools map -a {input.windows} \</span>
<span class="s2">      -b {input.bedgraph} \</span>
<span class="s2">      -c 4 -o mean -null 0 \</span>
<span class="s2">      | sort -k5,5n \</span>
<span class="s2">      | bedtools groupby \</span>
<span class="s2">        -i - \</span>
<span class="s2">        -g 5 -c 6 -o sum \</span>
<span class="s2">        &gt; {output.coverage}</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="nf">rule prepare_bed_data</span><span class="o">:</span>
  input:
    <span class="nv">genes</span> <span class="o">=</span> GENES,
    <span class="nv">chroms</span> <span class="o">=</span> CHROMS,
  output:
    <span class="nv">tss</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/tss.bed&quot;</span>,
    <span class="nv">tss_slop</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/tss_slop.bed&quot;</span>,
    <span class="nv">windows</span> <span class="o">=</span> <span class="s2">&quot;bedfiles/windows.bed&quot;</span>,
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    #get start sites</span>
<span class="s2">    awk &#39; {{OFS=&quot;</span><span class="se">\t</span><span class="s2">&quot;}}</span>
<span class="s2">      </span><span class="nv">$6</span><span class="s2"> == &quot;</span>+<span class="s2">&quot; {{print </span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">,</span><span class="nv">$2</span><span class="s2">+1,</span><span class="nv">$4</span><span class="s2">}} ;</span>
<span class="s2">      </span><span class="nv">$6</span><span class="s2"> == &quot;</span>-<span class="s2">&quot; {{print </span><span class="nv">$1</span><span class="s2">,</span><span class="nv">$3</span><span class="s2">-1,</span><span class="nv">$3</span><span class="s2">,</span><span class="nv">$4</span><span class="s2">}}&#39; {input.genes} &gt; {output.tss}</span>

<span class="s2">    #get +/- 2kbp and make windows</span>
<span class="s2">    bedtools slop \</span>
<span class="s2">      -b 2000 \</span>
<span class="s2">      -i {output.tss} \</span>
<span class="s2">      -g {input.chroms} \</span>
<span class="s2">      &gt; {output.tss_slop}</span>

<span class="s2">    bedtools makewindows -b {output.tss_slop} -w 5 -i srcwinnum \</span>
<span class="s2">      | sort -k1,1 -k2,2n \</span>
<span class="s2">      | tr &quot;</span>_<span class="s2">&quot; &quot;</span><span class="se">\t</span><span class="s2">&quot; \</span>
<span class="s2">      &gt; {output.windows}</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="nf">rule make_bedgraphs</span><span class="o">:</span>
  input:
    <span class="s2">&quot;bowtie/{chip}_sorted.bam&quot;</span>
  output:
    <span class="s2">&quot;bowtie/{chip}.bedgraph&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    bedtools genomecov \</span>
<span class="s2">      -ibam {input} \</span>
<span class="s2">      -bg \</span>
<span class="s2">      -g {CHROMS} \</span>
<span class="s2">      &gt; {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="nf">rule sort_index_bam</span><span class="o">:</span>
  input:
    <span class="s2">&quot;bowtie/{chip}.bam&quot;</span>
  output:
    <span class="s2">&quot;bowtie/{chip}_sorted.bam&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    samtools sort {input} &gt; {output}</span>
<span class="s2">    samtools index {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="nf">rule bowtie_mapping</span><span class="o">:</span>
  input:
    <span class="nv">fq</span> <span class="o">=</span> <span class="s2">&quot;raw_data/{chip}.fastq.gz&quot;</span>,
    <span class="nv">idx</span> <span class="o">=</span> <span class="s2">&quot;dbases/bowtie_idx/chr22.1.bt2&quot;</span>
  output:
    <span class="s2">&quot;bowtie/{chip}.bam&quot;</span>
  params:
    <span class="nv">idx</span> <span class="o">=</span> <span class="s2">&quot;dbases/bowtie_idx/chr22&quot;</span>,
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    bowtie2 \</span>
<span class="s2">      -x {params.idx} \</span>
<span class="s2">      -U {input.fq} \</span>
<span class="s2">      -S {output}</span>
<span class="s2">    &quot;&quot;&quot;</span>

<span class="nf">rule bowtie_index</span><span class="o">:</span>
  input:
    FASTA
  output:
    <span class="s2">&quot;dbases/bowtie_idx/chr22.1.bt2&quot;</span>
  params:
    <span class="nv">output_name</span> <span class="o">=</span> <span class="s2">&quot;dbases/bowtie_idx/chr22&quot;</span>
  shell:
    <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    bowtie2-build {input} {params.output_name}</span>
<span class="s2">    &quot;&quot;&quot;</span>
</pre></div>
</div>




    </article>
  </slide>  <slide class="level-2" id="generalizing-the-pipeline">
    <hgroup>
      <h2>Generalizing the pipeline<a class="headerlink" href="../../Classes/snakemake-tutorial.html#generalizing-the-pipeline" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <p>The real power of a pipeline is the ability to apply it to many datasets.
By adding additional elements to our <code class="docutils literal"><span class="pre">CHIP</span></code> variable we can now run our
pipeline on multiple Chip-Seq samples</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span><span class="nv">CHIP</span> <span class="o">=</span> <span class="o">[</span><span class="s2">&quot;H1_h3k4me3_chr22&quot;</span>, <span class="s2">&quot;H1_h3k4me3_chr21&quot;</span><span class="o">]</span>
</pre></div>
</div>
<p>Now our pipeline will run for both Chip-Seq datasets with only 1 filename
added!</p>
<p>What if you have a directory with 100s of fastq files from Chip-Seq
experiments? You could type out a long list of filenames, or you can use
the <code class="docutils literal"><span class="pre">glob_wildcards</span></code> function in Snakemake. This function will build a
list of sample names based on the files in the listed directory.</p>
<div class="highlight-basemake"><div class="highlight"><pre><span></span>CHIP, = glob_wildcards(&quot;raw_data/{chip}.fastq.gz&quot;)
</pre></div>
</div>
<p>Lastly, snakemake can run jobs in parallel. If your computer has more than
1 core you can execute more than 1 job at the same time. Snakemake handles
the scheduling, all you need to do is tell it the number of cores you want
to use.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>snakemake -pr --cores 2
</pre></div>
</div>




    </article>
  </slide>  <slide class="level-2" id="troubleshooting">
    <hgroup>
      <h2>Troubleshooting<a class="headerlink" href="../../Classes/snakemake-tutorial.html#troubleshooting" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <p><a class="reference external" href="https://snakemake.readthedocs.io/en/latest/project_info/faq.html">https://snakemake.readthedocs.io/en/latest/project_info/faq.html</a></p>
<p><a class="reference external" href="http://stackoverflow.com/questions/tagged/snakemake">http://stackoverflow.com/questions/tagged/snakemake</a></p>
<p><a class="reference external" href="https://groups.google.com/forum/#!forum/snakemake">https://groups.google.com/forum/#!forum/snakemake</a></p>
<p>Some helpful guidelines:</p>
<ol class="arabic simple">
<li>Indentation is important, use two or four spaces for each indentation.</li>
<li>Define your target (final output) files in rule all</li>
<li>Use unique extensions or directories for each rule to avoid wildcard
collisions</li>
</ol>




    </article>
  </slide>  <slide class="level-2" id="alternative-tutorials">
    <hgroup>
      <h2>Alternative tutorials<a class="headerlink" href="../../Classes/snakemake-tutorial.html#alternative-tutorials" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <p><a class="reference external" href="https://snakemake.readthedocs.io/en/latest/index.html">https://snakemake.readthedocs.io/en/latest/index.html</a></p>
<p><a class="reference external" href="https://github.com/leipzig/SandwichesWithSnakemake">https://github.com/leipzig/SandwichesWithSnakemake</a></p>




    </article>
  </slide>  <slide class="level-2" id="exercises">
    <hgroup>
      <h2>Exercises<a class="headerlink" href="../../Classes/snakemake-tutorial.html#exercises" title="View HTML">§</a></h2>
    </hgroup>
    <article class="">
      <ol class="arabic simple">
<li>Make a three rule snakemake pipeline using basic unix tools. Include at
least one wildcard variable.</li>
<li>Download the three fastqs in the following directory (To Do). Modify
our snakemake pipeline to run the analysis on all three fastqs. What do
you notice about the TSS coverage for each Chip-Seq expt?</li>
<li>Add additional rules to our pipeline to plot Chip-Seq coverage at the
3' transcriptional stop site.</li>
</ol>




    </article>
  </slide>


    <slide class="thank-you-slide segue nobackground">
    <article class="flexbox vleft auto-fadein">
      <h2>&lt;Thank You!&gt;</h2>
    </article>
    <p class="auto-fadein" data-config-contact>
      <!-- populated from slide_config.json -->
    </p>
  </slide>

  <slide class="backdrop"></slide>

</slides>

<!--[if IE]>
  <script src="http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js"></script>
  <script>CFInstall.check({mode: 'overlay'});</script>
<![endif]-->
</body>
</html>